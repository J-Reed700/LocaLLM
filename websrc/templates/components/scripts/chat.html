<script>
    function chat() {
        return {
            messages: [],
            conversations: {},
            currentConversationId: null,
            newMessage: '',
            isLoading: false,
            currentConversation: { type: "text", name: null },
            visibleConversations: [],
            isFetchingConversations: false,
            
            async initializeChat() {
                await this.loadConversations();
                if (Object.keys(this.conversations).length === 0) {
                    await this.startNewConversation();
                } else {
                    const firstConvId = parseInt(Object.keys(this.conversations)[0]);
                    await this.loadConversation(firstConvId);
                }
            },
            
            async startNewConversation(type = 'text') {
                try {
                    const modelSelect = document.querySelector('#global-model-select');
                    const modelName = modelSelect ? modelSelect.value : 'gpt2';

                    const response = await fetch('/conversations/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            title: 'New Conversation',
                            type: type,
                            name: modelName
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create conversation');
                    }

                    const newConversation = await response.json();
                    await this.loadConversations();
                    
                    if (newConversation && newConversation.id) {
                        this.currentConversationId = parseInt(newConversation.id);
                        await this.loadConversation(this.currentConversationId);
                    }

                    this.currentConversation = {type: type, name: modelName};

                } catch (error) {
                    console.error('Error starting new conversation:', error);
                    alert('Failed to create new conversation: ' + error.message);
                }
            },

            async loadConversation(id) {
                if (!id) return;
                
                try {

                    this.conversations[id].isActive = true;
                    this.currentConversationId = id;
                    
                    // Load messages for the conversation
                    const response = await fetch(`/conversations/${id}/messages`);
                    if (!response.ok) {
                        throw new Error('Failed to load messages');
                    }
                    
                    const data = await response.json();
                    this.messages = data.messages;
                    
                    // Scroll to bottom of message container
                    this.$nextTick(() => {
                        this.scrollToBottom();
                    });
                } catch (error) {
                    console.error('Error loading conversation:', error);
                }
            },
            
            async loadConversations() {
                this.isFetchingConversations = true;
                try {
                    const response = await fetch(`/conversations`);
                    if (!response.ok) {
                        throw new Error('Failed to load conversations');
                    }
                    const conversationList = await response.json();
                    
                    this.conversations = {};
                    this.visibleConversations = [];

                    conversationList.forEach(conv => {
                        this.conversations[conv.id] = {
                            ...conv,
                            isActive: false,
                            isEditing: false,
                            formattedDate: new Date(conv.created_at).toLocaleDateString()
                        };
                    });

                    const newVisibleConversations = conversationList.map(conv => ({
                        ...conv,
                        isActive: false,
                        isEditing: false,
                        formattedDate: new Date(conv.created_at).toLocaleDateString()
                    }));

                    // Append new conversations to visibleConversations
                    this.visibleConversations = [...newVisibleConversations];
                    
                } catch (error) {
                    console.error('Error loading conversations:', error);
                    this.conversations = {};
                    this.visibleConversations = [];
                } finally {
                    this.isFetchingConversations = false;
                }
            },

            async sendMessage() {
                if (!this.newMessage.trim() || this.isLoading || !this.currentConversationId) {
                    return;
                }
                
                // Add the user's message to the messages array immediately
                this.messages.push({
                    id: Date.now(),
                    role: 'user',
                    content: this.newMessage,
                });

                // Add a loading message
                const loadingMessageId = Date.now() + 1;
                this.messages.push({
                    id: loadingMessageId,
                    role: 'assistant',
                    content: 'Thinking...',
                    loading: true
                });

                const originalMessage = this.newMessage;
                this.newMessage = '';
                this.isLoading = true;

                // Scroll to bottom
                this.$nextTick(() => {
                    this.scrollToBottom();
                });

                try {
                    // Generate AI response based on conversation type
                    const endpoint = this.currentConversation.type === 'text' ? '/generate/text/' : '/generate/image/';
                        
                    const generateResponse = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: originalMessage,
                            conversation_id: this.currentConversationId
                        })
                    });

                    if (!generateResponse.ok) {
                        throw new Error('Failed to generate response');
                    }

                    // Get the HTML response text directly
                    const responseText = await generateResponse.text();

                    // Remove loading message and add real response
                    this.messages = this.messages.filter(m => m.id !== loadingMessageId);
                    this.messages.push({
                        id: Date.now(),
                        role: 'assistant',
                        content: responseText,
                    });

                    // Scroll to bottom
                    this.$nextTick(() => {
                        this.scrollToBottom();
                    });
                } catch (error) {
                    // Remove loading message and add error
                    this.messages = this.messages.filter(m => m.id !== loadingMessageId);
                    this.messages.push({
                        id: Date.now(),
                        role: 'system',
                        content: `Error: ${error.message}`,
                        error: true,
                    });
                } finally {
                    this.isLoading = false;
                }
            },

            async loadMessages(conversationId) {
                try {
                    const response = await fetch(`/conversations/${conversationId}/messages`);
                    if (!response.ok) {
                        throw new Error('Failed to load messages');
                    }
                    const data = await response.json();
                    this.messages = data.messages;
                    
                    this.$nextTick(() => {
                        this.scrollToBottom();
                    });
                } catch (error) {
                    console.error('Error loading messages:', error);
                }
            },

            scrollToBottom() {
                const container = this.$refs.messageContainer;
                container.scrollTop = container.scrollHeight;
            },

            formatDate(date) {
                return new Date(date).toLocaleDateString();
            },

            get sortedConversations() {
                return [...this.conversations].sort((a, b) => {
                    return new Date(b.created_at) - new Date(a.created_at);
                });
            },

            async deleteCurrentConversation() {
                if (!this.currentConversationId) return;
                
                if (!confirm('Are you sure you want to delete this conversation?')) {
                    return;
                }
                
                try {
                    const deletedId = this.currentConversationId;
                    
                    const response = await fetch(`/conversations/${deletedId}`, {
                        method: 'DELETE'
                    });

                    if (!response.ok) {
                        throw new Error('Failed to delete conversation');
                    }

                    this.currentConversationId = null;
                    this.messages = [];

                    await this.loadConversations();

                    const remainingConversations = Object.keys(this.conversations);
                    if (remainingConversations.length > 0) {
                        await this.loadConversation(remainingConversations[0]);
                    } else {
                        await this.startNewConversation();
                    }
                    
                } catch (error) {
                    console.error('Error deleting conversation:', error);
                    alert('Failed to delete conversation: ' + error.message);
                }
            },

            startEditing(conversation) {
                conversation.isEditing = true;
                conversation.editTitle = conversation.title || `Conversation ${conversation.id}`;
                // Focus the input after rendering
                this.$nextTick(() => {
                    this.$el.querySelector('input').focus();
                });
            },
            
            async saveTitle(conversation) {
                if (!conversation.isEditing) return;
                
                const newTitle = conversation.editTitle.trim();
                if (!newTitle || newTitle === conversation.title) {
                    this.cancelEditing(conversation);
                    return;
                }
                
                try {
                    const response = await fetch(`/conversations/${conversation.id}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            title: newTitle
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to update conversation title');
                    }
                    
                    conversation.title = newTitle;
                } catch (error) {
                    console.error('Error updating conversation title:', error);
                    alert('Failed to update conversation title: ' + error.message);
                } finally {
                    conversation.isEditing = false;
                    delete conversation.editTitle;
                }
            },
            
            cancelEditing(conversation) {
                conversation.isEditing = false;
                delete conversation.editTitle;
            },
            loadMoreConversations(event) {
                const element = event.target;
                if (element.scrollHeight - element.scrollTop === element.clientHeight) {
                    this.loadConversations();
                }
            },
        }
    }
</script>