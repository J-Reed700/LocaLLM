<script>
    function chat() {
        return {
            messages: [],
            conversations: {},
            currentConversationId: null,
            newMessage: '',
            isLoading: false,
            currentConversation: { type: "text", name: '{{ settings.MODEL_NAME }}' },
            visibleConversations: [],
            isFetchingConversations: false,
            showEditModal: false,
            editingConversation: {
                id: null,
                title: '',
                editSystemPrompt: ''
            },
            
            async initializeChat() {
                await this.loadConversations();
                if (Object.keys(this.conversations).length === 0) {
                    await this.startNewConversation();
                } else {
                    const firstConvId = parseInt(Object.keys(this.conversations)[0]);
                    await this.loadConversation(firstConvId);
                }
            },
            async startNewConversation(type = 'text') {
                try {
                    const modelName = '{{ settings.MODEL_NAME }}';

                    const response = await fetch('/conversations/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            title: 'New Conversation',
                            parameters: {
                                type: type,
                                name: modelName,
                                max_length: 1000,
                                temperature: 0.7,
                                top_p: 0.9,
                                top_k: 50,
                                repetition_penalty: 1.1
                            }
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create conversation');
                    }

                    const newConversation = await response.json();
                    await this.loadConversations();
                    
                    if (newConversation && newConversation.id) {
                        this.currentConversationId = parseInt(newConversation.id);
                        await this.loadConversation(this.currentConversationId);
                    }

                    this.currentConversation = {type: type, name: modelName};

                } catch (error) {
                    console.error('Error starting new conversation:', error);
                    alert('Failed to create new conversation: ' + error.message);
                }
            },

            async loadConversation(id) {
                if (!id) return;
                
                try {
                    const conversationResponse = await fetch(`/conversations/${id}`);
                    if (!conversationResponse.ok) throw new Error('Failed to load conversation');
                    
                    const conversation = await conversationResponse.json();
                    this.currentConversationId = id;
                    this.currentConversation = {
                        type: conversation.model_type,
                        name: conversation.model_name,
                        system_prompt: conversation.system_prompt
                    };
                    
                    // Update visible conversation with system prompt
                    if (this.conversations[id]) {
                        this.conversations[id].system_prompt = conversation.system_prompt;
                        this.conversations[id].editSystemPrompt = conversation.system_prompt || '';
                        this.conversations[id].isEditingSystemPrompt = false;
                    }
                    
                    // Load messages for the conversation
                    const messagesResponse = await fetch(`/conversations/${id}/messages`);
                    if (!messagesResponse.ok) {
                        throw new Error('Failed to load messages');
                    }
                    
                    const data = await messagesResponse.json();
                    this.messages = data.messages;
                    
                    // Scroll to bottom of message container
                    this.$nextTick(() => {
                        this.scrollToBottom();
                    });
                } catch (error) {
                    console.error('Error loading conversation:', error);
                }
            },
            
            async loadConversations() {
                this.isFetchingConversations = true;
                try {
                    const response = await fetch(`/conversations`);
                    if (!response.ok) {
                        throw new Error('Failed to load conversations');
                    }
                    const conversationList = await response.json();
                    
                    this.conversations = {};
                    this.visibleConversations = [];

                    conversationList.forEach(conv => {
                        this.conversations[conv.id] = {
                            ...conv,
                            isActive: false,
                            isEditing: false,
                            isEditingSystemPrompt: false,
                            editSystemPrompt: conv.system_prompt || '',
                            system_prompt: conv.system_prompt || '',
                            formattedDate: new Date(conv.created_at).toLocaleDateString()
                        };
                    });

                    const newVisibleConversations = conversationList.map(conv => ({
                        ...conv,
                        isActive: false,
                        isEditing: false,
                        isEditingSystemPrompt: false,
                        editSystemPrompt: conv.system_prompt || '',
                        system_prompt: conv.system_prompt || '',
                        formattedDate: new Date(conv.created_at).toLocaleDateString()
                    }));

                    // Append new conversations to visibleConversations
                    this.visibleConversations = [...newVisibleConversations];
                    
                } catch (error) {
                    console.error('Error loading conversations:', error);
                    this.conversations = {};
                    this.visibleConversations = [];
                } finally {
                    this.isFetchingConversations = false;
                }
            },

            async sendMessage() {
                if (!this.newMessage.trim() || this.isLoading || !this.currentConversationId) {
                    return;
                }
                
                // Add the user's message to the messages array immediately
                this.messages.push({
                    id: Date.now(),
                    role: 'user',
                    content: this.newMessage,
                });

                // Add a loading message
                const loadingMessageId = Date.now() + 1;
                this.messages.push({
                    id: loadingMessageId,
                    role: 'assistant',
                    content: 'Thinking...',
                    loading: true
                });

                const originalMessage = this.newMessage;
                this.newMessage = '';
                this.isLoading = true;

                // Scroll to bottom
                this.$nextTick(() => {
                    this.scrollToBottom();
                });

                try {
                    // Generate AI response based on conversation type
                    const endpoint = this.currentConversation.type === 'text' ? '/generate/text/' : '/generate/image/';
                        
                    const generateResponse = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: originalMessage,
                            conversation_id: this.currentConversationId,
                            type: this.currentConversation.type,
                            name: this.currentConversation.name || '{{ settings.MODEL_NAME }}',
                            max_length: 1000,
                            temperature: 0.7
                        })
                    });

                    if (!generateResponse.ok) {
                        throw new Error('Failed to generate response');
                    }

                    // Get the response based on content type
                    const contentType = generateResponse.headers.get('content-type');
                    let responseContent;
                    
                    if (contentType && contentType.includes('application/json')) {
                        const jsonResponse = await generateResponse.json();
                        responseContent = jsonResponse.text;
                    } else {
                        responseContent = await generateResponse.text();
                    }

                    // Remove loading message and add real response
                    this.messages = this.messages.filter(m => m.id !== loadingMessageId);
                    this.messages.push({
                        id: Date.now(),
                        role: 'assistant',
                        content: responseContent,
                    });

                    // Scroll to bottom
                    this.$nextTick(() => {
                        this.scrollToBottom();
                    });
                } catch (error) {
                    // Remove loading message and add error
                    this.messages = this.messages.filter(m => m.id !== loadingMessageId);
                    this.messages.push({
                        id: Date.now(),
                        role: 'system',
                        content: `Error: ${error.message}`,
                        error: true,
                    });
                } finally {
                    this.isLoading = false;
                }
            },

            async loadMessages(conversationId) {
                try {
                    const response = await fetch(`/conversations/${conversationId}/messages`);
                    if (!response.ok) {
                        throw new Error('Failed to load messages');
                    }
                    const data = await response.json();
                    this.messages = data.messages;
                    
                    this.$nextTick(() => {
                        this.scrollToBottom();
                    });
                } catch (error) {
                    console.error('Error loading messages:', error);
                }
            },

            scrollToBottom() {
                const container = this.$refs.messageContainer;
                container.scrollTop = container.scrollHeight;
            },

            formatDate(date) {
                return new Date(date).toLocaleDateString();
            },

            get sortedConversations() {
                return [...this.conversations].sort((a, b) => {
                    return new Date(b.created_at) - new Date(a.created_at);
                });
            },

            async deleteCurrentConversation() {
                if (!this.currentConversationId) return;
                
                if (!confirm('Are you sure you want to delete this conversation?')) {
                    return;
                }
                
                try {
                    const deletedId = this.currentConversationId;
                    
                    const response = await fetch(`/conversations/${deletedId}`, {
                        method: 'DELETE'
                    });

                    if (!response.ok) {
                        throw new Error('Failed to delete conversation');
                    }

                    this.currentConversationId = null;
                    this.messages = [];

                    await this.loadConversations();

                    const remainingConversations = Object.keys(this.conversations);
                    if (remainingConversations.length > 0) {
                        await this.loadConversation(remainingConversations[0]);
                    } else {
                        await this.startNewConversation();
                    }
                    
                } catch (error) {
                    console.error('Error deleting conversation:', error);
                    alert('Failed to delete conversation: ' + error.message);
                }
            },

            startEditing(conversation) {
                conversation.isEditing = true;
                conversation.editTitle = conversation.title || `Conversation ${conversation.id}`;
                // Focus the input after rendering
                this.$nextTick(() => {
                    this.$el.querySelector('input').focus();
                });
            },
            
            async saveTitle(conversation) {
                if (!conversation.isEditing) return;
                
                const newTitle = conversation.editTitle.trim();
                if (!newTitle || newTitle === conversation.title) {
                    this.cancelEditing(conversation);
                    return;
                }
                
                try {
                    const response = await fetch(`/conversations/${conversation.id}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            title: newTitle
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to update conversation title');
                    }
                    
                    conversation.title = newTitle;
                } catch (error) {
                    console.error('Error updating conversation title:', error);
                    alert('Failed to update conversation title: ' + error.message);
                } finally {
                    conversation.isEditing = false;
                    delete conversation.editTitle;
                }
            },
            
            cancelEditing(conversation) {
                conversation.isEditing = false;
                delete conversation.editTitle;
            },
            loadMoreConversations(event) {
                const element = event.target;
                if (element.scrollHeight - element.scrollTop === element.clientHeight) {
                    this.loadConversations();
                }
            },

            toggleSystemPrompt(conversation) {
                conversation.isEditingSystemPrompt = !conversation.isEditingSystemPrompt;
                if (conversation.isEditingSystemPrompt) {
                    conversation.editSystemPrompt = conversation.system_prompt || '';
                }
            },
            
            async saveSystemPrompt(conversation) {
                if (!conversation.editSystemPrompt?.trim()) {
                    conversation.editSystemPrompt = '';
                }
                
                try {
                    const response = await fetch(`/conversations/${conversation.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            title: conversation.title,
                            system_prompt: conversation.editSystemPrompt
                        })
                    });
                    
                    if (!response.ok) throw new Error('Failed to update system prompt');
                    
                    conversation.system_prompt = conversation.editSystemPrompt;
                    conversation.isEditingSystemPrompt = false;
                    
                    if (conversation.id === this.currentConversationId) {
                        this.currentConversation.system_prompt = conversation.system_prompt;
                    }

                    await this.loadConversations();
                    
                } catch (error) {
                    console.error('Error saving system prompt:', error);
                    alert('Failed to save system prompt');
                }
            },
            
            cancelSystemPromptEdit(conversation) {
                conversation.editSystemPrompt = conversation.system_prompt || '';
                conversation.isEditingSystemPrompt = false;
            },

            openEditModal(conversation) {
                this.editingConversation = {
                    id: conversation.id,
                    title: conversation.title,
                    editSystemPrompt: conversation.system_prompt || ''
                };
                this.showEditModal = true;
            },

            async saveConversationEdits() {
                if (!this.editingConversation) return;
                
                try {
                    const response = await fetch(`/conversations/${this.editingConversation.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            title: this.editingConversation.title,
                            system_prompt: this.editingConversation.editSystemPrompt
                        })
                    });
                    
                    if (!response.ok) throw new Error('Failed to update conversation');
                    
                    // Update local state
                    const conversation = this.conversations[this.editingConversation.id];
                    if (conversation) {
                        conversation.title = this.editingConversation.title;
                        conversation.system_prompt = this.editingConversation.editSystemPrompt;
                    }
                    
                    // Update current conversation if it's the active one
                    if (this.editingConversation.id === this.currentConversationId) {
                        this.currentConversation.system_prompt = this.editingConversation.editSystemPrompt;
                    }
                    
                    this.showEditModal = false;
                    this.editingConversation = {
                        id: null,
                        title: '',
                        editSystemPrompt: ''
                    };

                    await this.loadConversations();
                    
                } catch (error) {
                    console.error('Error updating conversation:', error);
                    alert('Failed to update conversation');
                }
            },

            closeEditModal() {
                this.showEditModal = false;
                this.editingConversation = {
                    id: null,
                    title: '',
                    editSystemPrompt: ''
                };
            }
        }
    }
</script>