<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>locaLLM Studio</title>
    <!-- Modern minimal stack -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#1e40af',
                        dark: {
                            DEFAULT: '#0f172a',
                            lighter: '#1e293b',
                            card: '#1e293b',
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-dark">
    {% include 'components/nav.html' %}
    {% with page_type='Home' %}
        {% include 'components/settings-modal.html' %}
    {% endwith %}
    
    <div class="flex h-[calc(100vh-4rem)]" x-data="chat()" x-init="initializeChat">
        <!-- Conversation Sidebar -->
        <div class="w-64 bg-dark-lighter h-full overflow-y-auto">
            <div class="p-4 space-y-2">
                <template x-for="conversation in Object.values(conversations)" :key="conversation.id">
                    <div 
                        class="conversation-card transform transition-all duration-200 hover:scale-102 cursor-pointer"
                        :class="{
                            'bg-primary/10 border-primary': currentConversationId === conversation.id,
                            'bg-dark-card border-gray-700': currentConversationId !== conversation.id
                        }"
                        @click="loadConversation(conversation.id)"
                    >
                        <div class="p-4 rounded-lg border">
                            <div class="flex flex-col">
                                <!-- Title with edit functionality -->
                                <div class="flex items-center justify-between">
                                    <h3 
                                        x-show="!conversation.isEditing"
                                        class="font-medium truncate"
                                        :class="{
                                            'text-primary': currentConversationId === conversation.id,
                                            'text-gray-200': currentConversationId !== conversation.id
                                        }"
                                        x-text="conversation.title || `Conversation ${conversation.id}`"
                                        @dblclick="startEditing(conversation)"
                                    ></h3>
                                    <input
                                        x-show="conversation.isEditing"
                                        type="text"
                                        x-model="conversation.editTitle"
                                        @blur="saveTitle(conversation)"
                                        @keyup.enter="saveTitle(conversation)"
                                        @keyup.escape="cancelEditing(conversation)"
                                        class="w-full bg-dark-lighter text-gray-200 px-2 py-1 rounded border border-gray-700 focus:border-primary focus:ring-1 focus:ring-primary"
                                        @click.stop
                                    />
                                    <button 
                                        x-show="!conversation.isEditing"
                                        @click.stop="startEditing(conversation)" 
                                        class="ml-2 text-gray-400 hover:text-primary"
                                    >
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                                        </svg>
                                    </button>
                                </div>
                                <span class="text-xs text-gray-500 mt-1" x-text="conversation.formattedDate"></span>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Main Chat Area -->
        <main class="flex-1 flex flex-col p-6 space-y-4">
            
            <!-- Chat Messages -->
            <div class="flex-1 bg-dark-lighter rounded-xl shadow-lg border border-gray-800/50 p-6 overflow-y-auto"
                 x-ref="messageContainer">
                <template x-for="message in messages" :key="message.id">
                    <template x-if="!message.error">
                        <div class="message-wrapper mb-4"
                             :class="message.role === 'user' ? 'text-right' : 'text-left'">
                            <div class="inline-block max-w-2/3 p-4 rounded-xl"
                                 :class="message.role === 'user' ? 
                                        'bg-primary text-white rounded-br-sm' : 
                                        'bg-dark border border-gray-800/50 text-gray-300 rounded-bl-sm'">
                                <p x-text="message.content"></p>
                                <div x-show="message.loading" 
                                     class="loading-indicator mt-2">
                                    <div class="dot-flashing"></div>
                                </div>
                            </div>
                        </div>
                    </template>
                    <template x-if="message.error">
                        <div class="bg-red-500/10 border border-red-500/20 text-red-400 p-4 rounded-xl mb-4">
                            <p x-text="message.content"></p>
                        </div>
                    </template>
                </template>
            </div>

            <!-- Input Area -->
            <div class="bg-dark-lighter rounded-xl shadow-lg border border-gray-800/50 p-6">
                <form @submit.prevent="sendMessage" class="flex gap-4 items-center">
                    <textarea 
                        x-model="newMessage"
                        @keydown.enter.prevent="sendMessage"
                        :disabled="isLoading"
                        class="flex-1 p-2 bg-dark border border-gray-800 rounded-lg focus:border-primary focus:ring-2 focus:ring-primary/20 resize-none text-gray-300 placeholder-gray-500"
                        placeholder="Type your message..."
                        rows="1"></textarea>
                    
                    <div class="inline-flex h-10">
                        <button 
                            type="submit"
                            :disabled="isLoading || !newMessage.trim()"
                            class="px-4 h-full bg-primary hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-l-lg border-r border-primary/20">
                            Send
                        </button>
                        
                        <div class="relative" x-data="{ dropdownOpen: false }">
                            <button
                                @click="dropdownOpen = !dropdownOpen"
                                type="button"
                                class="h-full px-2 bg-primary hover:bg-primary/90 text-white rounded-r-lg">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                </svg>
                            </button>
                            
                            <div 
                                x-show="dropdownOpen"
                                @click.away="dropdownOpen = false"
                                class="absolute right-0 bottom-full mb-2 w-48 bg-dark-lighter rounded-lg shadow-lg border border-gray-800/50 overflow-hidden">
                                <a href="#" 
                                   @click.prevent="startNewConversation('text')"
                                   class="block px-4 py-2 text-sm text-gray-300 hover:bg-dark">
                                    New Text Chat
                                </a>
                                <a href="#" 
                                   @click.prevent="startNewConversation('image')"
                                   class="block px-4 py-2 text-sm text-gray-300 hover:bg-dark">
                                    New Image Chat
                                </a>
                                <a href="#" 
                                   @click.prevent="deleteCurrentConversation()"
                                   class="block px-4 py-2 text-sm text-red-400 hover:bg-dark">
                                    Delete Conversation
                                </a>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
        </main>
    </div>

    <script>
        function chat() {
            return {
                messages: [],
                conversations: {},
                currentConversationId: null,
                newMessage: '',
                isLoading: false,
                currentConversation: { type: "text", name: null },
                
                async initializeChat() {
                    await this.loadConversations();
                    if (Object.keys(this.conversations).length === 0) {
                        await this.startNewConversation();
                    } else {
                        const firstConvId = Object.keys(this.conversations)[0];
                        await this.loadConversation(firstConvId);
                    }
                },
                
                async startNewConversation(type = 'text') {
                    try {
                        const modelSelect = document.querySelector('#global-model-select');
                        const modelName = modelSelect ? modelSelect.value : 'gpt2';

                        const response = await fetch('/conversations/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                title: 'New Conversation',
                                type: type,
                                name: modelName
                            })
                        });

                        if (!response.ok) {
                            throw new Error('Failed to create conversation');
                        }

                        const newConversation = await response.json();
                        await this.loadConversations();
                        
                        if (newConversation && newConversation.id) {
                            await this.loadConversation(newConversation.id);
                        }

                        this.currentConversation = {type: type, name: modelName};

                    } catch (error) {
                        console.error('Error starting new conversation:', error);
                        alert('Failed to create new conversation: ' + error.message);
                    }
                },

                async loadConversation(id) {
                    if (!id || id === this.currentConversationId) return;
                    
                    try {
                        // Update active states
                        if (this.currentConversationId) {
                            this.conversations[this.currentConversationId].isActive = false;
                        }
                        this.conversations[id].isActive = true;
                        this.currentConversationId = id;
                        
                        // Load messages for the conversation
                        const response = await fetch(`/conversations/${id}/messages`);
                        if (!response.ok) {
                            throw new Error('Failed to load messages');
                        }
                        
                        const data = await response.json();
                        this.messages = data.messages;
                        
                        // Scroll to bottom of message container
                        this.$nextTick(() => {
                            this.scrollToBottom();
                        });
                    } catch (error) {
                        console.error('Error loading conversation:', error);
                    }
                },
                
                async loadConversations() {
                    try {
                        const response = await fetch('/conversations/');
                        if (!response.ok) {
                            throw new Error('Failed to load conversations');
                        }
                        const conversationList = await response.json();
                        
                        // Convert array to dictionary with ID as key
                        this.conversations = conversationList.reduce((acc, conv) => {
                            acc[conv.id] = {
                                ...conv,
                                isActive: false,
                                isEditing: false,
                                formattedDate: new Date(conv.created_at).toLocaleDateString()
                            };
                            return acc;
                        }, {});
                    } catch (error) {
                        console.error('Error loading conversations:', error);
                        this.conversations = {};
                    }
                },

                async sendMessage() {
                    if (!this.newMessage.trim() || this.isLoading) return;
                    
                    this.isLoading = true;
                    const originalMessage = this.newMessage;
                    
                    try {
                        // Add user message to conversation
                        const messageResponse = await fetch(`/conversations/${this.currentConversationId}/messages`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                role: 'user',
                                content: originalMessage
                            })
                        });

                        if (!messageResponse.ok) {
                            throw new Error('Failed to send message');
                        }

                        this.newMessage = '';

                        // Generate AI response based on conversation type
                        const endpoint = this.currentConversation.type === 'text' ? 
                            '/generate/text/' : '/generate/image/';
                            
                        const generateResponse = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                prompt: originalMessage,
                                conversation_id: this.currentConversationId
                            })
                        });

                        if (!generateResponse.ok) {
                            throw new Error('Failed to generate response');
                        }

                        await this.loadMessages(this.currentConversationId);

                    } catch (error) {
                        console.error('Error:', error);
                        this.newMessage = originalMessage;
                        alert(error.message);
                    } finally {
                        this.isLoading = false;
                    }
                },

                async loadMessages(conversationId) {
                    try {
                        const response = await fetch(`/conversations/${conversationId}/messages`);
                        if (!response.ok) {
                            throw new Error('Failed to load messages');
                        }
                        const data = await response.json();
                        this.messages = data.messages;
                        
                        this.$nextTick(() => {
                            this.scrollToBottom();
                        });
                    } catch (error) {
                        console.error('Error loading messages:', error);
                    }
                },

                scrollToBottom() {
                    const container = this.$refs.messageContainer;
                    container.scrollTop = container.scrollHeight;
                },

                formatDate(date) {
                    return new Date(date).toLocaleDateString();
                },

                get sortedConversations() {
                    return [...this.conversations].sort((a, b) => {
                        return new Date(b.created_at) - new Date(a.created_at);
                    });
                },

                async deleteCurrentConversation() {
                    if (!this.currentConversationId) return;
                    
                    if (!confirm('Are you sure you want to delete this conversation?')) {
                        return;
                    }
                    
                    try {
                        // Store the current conversation's position
                        const conversationIds = Object.keys(this.conversations);
                        const currentIndex = conversationIds.indexOf(this.currentConversationId.toString());
                        
                        const response = await fetch(`/conversations/${this.currentConversationId}`, {
                            method: 'DELETE'
                        });

                        if (!response.ok) {
                            throw new Error('Failed to delete conversation');
                        }

                        // Remove from local state
                        delete this.conversations[this.currentConversationId];
                        
                        // Reset current conversation
                        this.currentConversationId = null;
                        this.messages = [];
                        
                        // Load the conversation that was above the deleted one
                        if (Object.keys(this.conversations).length > 0) {
                            const newIndex = Math.max(0, currentIndex - 1);
                            const newConversationId = conversationIds[newIndex];
                            await this.loadConversation(newConversationId);
                        } else {
                            await this.startNewConversation();
                        }
                        
                    } catch (error) {
                        console.error('Error deleting conversation:', error);
                        alert('Failed to delete conversation: ' + error.message);
                    }
                },

                startEditing(conversation) {
                    conversation.isEditing = true;
                    conversation.editTitle = conversation.title || `Conversation ${conversation.id}`;
                    // Focus the input after rendering
                    this.$nextTick(() => {
                        this.$el.querySelector('input').focus();
                    });
                },
                
                async saveTitle(conversation) {
                    if (!conversation.isEditing) return;
                    
                    const newTitle = conversation.editTitle.trim();
                    if (!newTitle || newTitle === conversation.title) {
                        this.cancelEditing(conversation);
                        return;
                    }
                    
                    try {
                        const response = await fetch(`/conversations/${conversation.id}`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                title: newTitle
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error('Failed to update conversation title');
                        }
                        
                        conversation.title = newTitle;
                    } catch (error) {
                        console.error('Error updating conversation title:', error);
                        alert('Failed to update conversation title: ' + error.message);
                    } finally {
                        conversation.isEditing = false;
                        delete conversation.editTitle;
                    }
                },
                
                cancelEditing(conversation) {
                    conversation.isEditing = false;
                    delete conversation.editTitle;
                }
            }
        }
    </script>
    <style>
    .loading-spinner {
        display: inline-block;
        width: 24px;
        height: 24px;
        border: 2px solid var(--primary);
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    </style>

    <script>
    document.addEventListener('htmx:configRequest', function(evt) {
        const target = evt.detail.elt.getAttribute('hx-target');
        const responseDiv = document.querySelector(target);
        const spinner = responseDiv.querySelector('.loading-spinner');
        if (spinner) spinner.hidden = false;
    });

    document.addEventListener('htmx:afterSwap', function(evt) {
        const target = evt.detail.elt.getAttribute('hx-target');
        const responseDiv = document.querySelector(target);
        const spinner = responseDiv.querySelector('.loading-spinner');
        if (spinner) spinner.hidden = true;
    });
    </script>

    <style>
        .conversation-card {
            transition: all 0.2s ease-in-out;
        }
        
        .conversation-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                        0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        .conversation-card.active {
            border-color: var(--primary);
        }
    </style>
</body>
</html>